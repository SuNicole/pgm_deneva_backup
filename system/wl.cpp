/*
   Copyright 2016 Massachusetts Institute of Technology

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "wl.h"
#include "config.h"
#include "catalog.h"
#include "global.h"
#include "helper.h"
#include "index_btree.h"
#include "index_hash.h"
#include "index_rdma.h"
#include "index_rdma_btree.h"
#include "mem_alloc.h"
#include "row.h"
#include "table.h"

RC Workload::init() { return RCOK; }
#if RDMA_ONE_SIDE == true
RC Workload::init_schema(const char * schema_file) {
	assert(sizeof(uint64_t) == 8);
	assert(sizeof(double) == 8);
	string line;
  	uint32_t id = 0;
    int num = 0,order_num = 0;
	ifstream fin(schema_file);
	while (getline(fin, line)) {
		if (line.compare(0, 6, "TABLE=") == 0) {
			string tname(&line[6]);

			getline(fin, line);
			cout<<"Init table "<<tname<<endl;
			int col_count = 0;
			// Read all fields for this table.
			vector<string> lines;
			while (line.length() > 1) {
				lines.push_back(line);
				cout<<line<<endl;
				getline(fin, line);
			}
			cout<<"Has "<<lines.size()<<" column"<<endl;

			void* tmp = new char[CL_SIZE * 2 + sizeof(table_t)];
			table_t * cur_tab = (table_t *) ((UInt64)tmp + CL_SIZE);
			// cur_tab->init(schema);
			// table_t * cur_tab = (table_t*)r2::AllocatorMaster<>::get_thread_allocator()->alloc(sizeof(table_t));
			Catalog *schema = &cur_tab->schema;
			schema->init( tname.c_str(), id++, lines.size() );
			cur_tab->init(tname.c_str(), schema->table_id);
			for (UInt32 i = 0; i < lines.size(); i++) {
				string line = lines[i];
				vector<string> items;

				char * line_cstr = new char [line.length()+1];
				strcpy(line_cstr,line.c_str());
				int size = atoi(strtok(line_cstr,","));
				char * type = strtok(NULL,",");
				char * name = strtok(NULL,",");

				schema->add_col(name, size, type);
				col_count ++;
			}
			tables[tname] = cur_tab;
		} else if (!line.compare(0, 6, "INDEX=")) {
			string iname(&line[6]);
			getline(fin, line);
	  		cout<<"Init index "<<iname<<endl;
			vector<string> items;
			string token;
			size_t pos;
			while (line.length() != 0) {
				pos = line.find(","); // != std::string::npos) {
				if (pos == string::npos) pos = line.length();
				token = line.substr(0, pos);
				items.push_back(token);
				line.erase(0, pos + 1);
				cout<<"token "<<token<<endl;
			}

			string tname(items[0]);
			int field_cnt = items.size() - 1;
			uint64_t * fields = new uint64_t [field_cnt];
			INDEX * index = new INDEX;
			for (int i = 0; i < field_cnt; i++) fields[i] = atoi(items[i + 1].c_str());
			int part_cnt __attribute__ ((unused));
			part_cnt = (CENTRAL_INDEX)? 1 : g_part_cnt;

	  		uint64_t table_size = g_synth_table_size;
            uint64_t index_table = 0; 
#if WORKLOAD == TPCC
            if ( !tname.compare(1, 4, "ITEM") ) {
				table_size = g_max_items;
                index_table = 0;
				printf("ITEM size %ld\n",table_size);
			} else if ( !tname.compare(1, 9, "WAREHOUSE") ) {
				table_size = g_num_wh / g_part_cnt;
                index_table = 1;
				printf("WAREHOUSE size %ld\n",table_size);
			} else if ( !tname.compare(1, 8, "DISTRICT") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh;
                index_table = 2;
				printf("DISTRICT size %ld\n",table_size);
			} else if ( !tname.compare(1, 8, "CUSTOMER") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh * g_cust_per_dist;
				printf("CUSTOMER size %ld\n",table_size);
                printf("tname = %s\n",tname.c_str());
                printf("iname = %s\n",iname.c_str());
                if ( iname=="CUSTOMER_LAST_IDX" )index_table = 4;
                else index_table = 3;
			} else if ( !tname.compare(1, 5, "STOCK") ) {
				table_size = g_num_wh / g_part_cnt * g_max_items;
                index_table = 5;
				printf("STOCK size %ld\n",table_size);
			} else if ( !tname.compare(1, 5, "ORDER") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh * g_cust_per_dist;
				printf("ORDER size %ld\n",table_size);
                if(iname == "ORDER-LINE_IDX")index_table = 7;
                else index_table = 6;
			}else if ( !tname.compare(1, 7, "HISTORY") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh * g_cust_per_dist;
                index_table = 8;
				printf("HISTORY size %ld\n",table_size);
			}  
#elif WORKLOAD == PPS
			if ( !tname.compare(1, 5, "PARTS") ) {
				table_size = MAX_PPS_PART_KEY;
			} else if (!tname.compare(1, 8, "PRODUCTS")) {
				table_size = MAX_PPS_PRODUCT_KEY;
			} else if (!tname.compare(1, 9, "SUPPLIERS")) {
				table_size = MAX_PPS_SUPPLIER_KEY;
			} else if (!tname.compare(1, 8, "SUPPLIES")) {
				table_size = MAX_PPS_PRODUCT_KEY;
			} else if (!tname.compare(1, 4, "USES")) {
				table_size = MAX_PPS_SUPPLIER_KEY;
			}
#elif WORKLOAD == DA
			if (!tname.compare(1, 5, "DAtab")) {
				table_size = MAX_DA_TABLE_SIZE;
			}
#else
	  		table_size = g_synth_table_size / g_part_cnt;
#endif


#if INDEX_STRUCT == IDX_HASH
			index->init(1024, tables[tname], table_size);

#elif INDEX_STRUCT == IDX_RDMA
          //  printf("********%s*********\n",tables[tname]->get_table_name());
        #if WORKLOAD == TPCC
            printf("\n***table index = %ld **\n",index_table);
            index->init(index_table, tables[tname], table_size); 
        #else
            index->init(1024, tables[tname], table_size); 
        #endif   
#elif INDEX_STRUCT == IDX_RDMA_BTREE
            index->init(part_cnt, tables[tname]);
#else
			index->init(part_cnt, tables[tname]);
#endif
			indexes[iname] = index;
			printf("iname:%s init over\n",iname.c_str());
		}
	}
	fin.close();
	return RCOK;
}

#else
RC Workload::init_schema(const char * schema_file) {
	assert(sizeof(uint64_t) == 8);
	assert(sizeof(double) == 8);
	string line;
  	uint32_t id = 0;
	ifstream fin(schema_file);
	Catalog * schema;
	while (getline(fin, line)) {
		if (line.compare(0, 6, "TABLE=") == 0) {
			string tname(&line[6]);
			void * tmp = new char[CL_SIZE * 2 + sizeof(Catalog)];
			schema = (Catalog *) ((UInt64)tmp + CL_SIZE);
			getline(fin, line);
			cout<<"Init table "<<tname<<endl;
			int col_count = 0;
			// Read all fields for this table.
			vector<string> lines;
			while (line.length() > 1) {
				lines.push_back(line);
				cout<<line<<endl;
				getline(fin, line);
			}
			cout<<"Has "<<lines.size()<<" column"<<endl;

			schema->init( tname.c_str(), id++, lines.size() );
			for (UInt32 i = 0; i < lines.size(); i++) {
				string line = lines[i];
				vector<string> items;

				char * line_cstr = new char [line.length()+1];
				strcpy(line_cstr,line.c_str());
				int size = atoi(strtok(line_cstr,","));
				char * type = strtok(NULL,",");
				char * name = strtok(NULL,",");

				schema->add_col(name, size, type);
				col_count ++;
			}
			tmp = new char[CL_SIZE * 2 + sizeof(table_t)];
			table_t * cur_tab = (table_t *) ((UInt64)tmp + CL_SIZE);
			cur_tab->init(schema);
			tables[tname] = cur_tab;
		} else if (!line.compare(0, 6, "INDEX=")) {
			string iname(&line[6]);
			getline(fin, line);
	  		cout<<"Init index "<<iname<<endl;
			vector<string> items;
			string token;
			size_t pos;
			while (line.length() != 0) {
				pos = line.find(","); // != std::string::npos) {
				if (pos == string::npos) pos = line.length();
				token = line.substr(0, pos);
				items.push_back(token);
				line.erase(0, pos + 1);
				cout<<"token "<<token<<endl;
			}

			string tname(items[0]);
			int field_cnt = items.size() - 1;
			uint64_t * fields = new uint64_t [field_cnt];
			INDEX * index = new INDEX;
			for (int i = 0; i < field_cnt; i++) fields[i] = atoi(items[i + 1].c_str());
			int part_cnt __attribute__ ((unused));
			part_cnt = (CENTRAL_INDEX)? 1 : g_part_cnt;

	  		uint64_t table_size = g_synth_table_size;
#if WORKLOAD == TPCC
			if ( !tname.compare(1, 9, "WAREHOUSE") ) {
				table_size = g_num_wh / g_part_cnt;
				printf("WAREHOUSE size %ld\n",table_size);
			} else if ( !tname.compare(1, 8, "DISTRICT") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh;
				printf("DISTRICT size %ld\n",table_size);
			} else if ( !tname.compare(1, 8, "CUSTOMER") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh * g_cust_per_dist;
				printf("CUSTOMER size %ld\n",table_size);
			} else if ( !tname.compare(1, 7, "HISTORY") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh * g_cust_per_dist;
				printf("HISTORY size %ld\n",table_size);
			} else if ( !tname.compare(1, 5, "ORDER") ) {
				table_size = g_num_wh / g_part_cnt * g_dist_per_wh * g_cust_per_dist;
				printf("ORDER size %ld\n",table_size);
			} else if ( !tname.compare(1, 4, "ITEM") ) {
				table_size = g_max_items;
				printf("ITEM size %ld\n",table_size);
			} else if ( !tname.compare(1, 5, "STOCK") ) {
				table_size = g_num_wh / g_part_cnt * g_max_items;
				printf("STOCK size %ld\n",table_size);
			}
#elif WORKLOAD == PPS
			if ( !tname.compare(1, 5, "PARTS") ) {
				table_size = MAX_PPS_PART_KEY;
			} else if (!tname.compare(1, 8, "PRODUCTS")) {
				table_size = MAX_PPS_PRODUCT_KEY;
			} else if (!tname.compare(1, 9, "SUPPLIERS")) {
				table_size = MAX_PPS_SUPPLIER_KEY;
			} else if (!tname.compare(1, 8, "SUPPLIES")) {
				table_size = MAX_PPS_PRODUCT_KEY;
			} else if (!tname.compare(1, 4, "USES")) {
				table_size = MAX_PPS_SUPPLIER_KEY;
			}
#elif WORKLOAD == DA
			if (!tname.compare(1, 5, "DAtab")) {
				table_size = MAX_DA_TABLE_SIZE;
			}
#else
	  		table_size = g_synth_table_size / g_part_cnt;
#endif


#if INDEX_STRUCT == IDX_HASH
			index->init(1024, tables[tname], table_size);

#elif INDEX_STRUCT == IDX_RDMA
            index->init(1024, tables[tname], table_size); 
#elif INDEX_STRUCT == IDX_RDMA_BTREE
            index->init(part_cnt, tables[tname]);
#else
			index->init(part_cnt, tables[tname]);
#endif
			indexes[iname] = index;
			printf("iname:%s init over\n",iname.c_str());
		}
	}
	fin.close();
	return RCOK;
}
#endif
//add by ym origin function mark
void Workload::index_delete_all() {
  #if WORKLOAD ==DA
	for (auto index :indexes) {
	  index.second->index_reset();
	}
  #endif
}

void Workload::index_insert(string index_name, uint64_t key, row_t * row) {
	assert(false);
	INDEX * index = (INDEX *) indexes[index_name];
	index_insert(index, key, row);
}

void Workload::index_insert(INDEX * index, uint64_t key, row_t * row, int64_t part_id) {
   // printf("【wl.cpp:300】index_key = %ld\n",key);
	uint64_t pid = part_id;
  if (part_id == -1) pid = get_part_id(row);
  itemid_t *m_item = (itemid_t *)mem_allocator.alloc(sizeof(itemid_t));
	m_item->init();
	m_item->type = DT_row;
	m_item->location = row;
	m_item->valid = true;

  assert(index);
  assert( index->index_insert(key, m_item, pid) == RCOK );
}

void Workload::index_insert_nonunique(INDEX * index, uint64_t key, row_t * row, int64_t part_id) {
	uint64_t pid = part_id;
	if (part_id == -1) pid = get_part_id(row);
	itemid_t *m_item = (itemid_t *)mem_allocator.alloc(sizeof(itemid_t));
	m_item->init();
	m_item->type = DT_row;
	m_item->location = row;
	m_item->valid = true;

	assert(index);
	assert( index->index_insert_nonunique(key, m_item, pid) == RCOK );
}



